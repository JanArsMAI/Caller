# Онлайн чат (V 1.0.0)
Целью этого небольшого проекта являлась работа с websocket, а также реализовать концепцию сервера с использованием комнат, куда могут подключаться клиенты. В процессе разработки была добавлена ещё одна глобальная цель: поработать с Redis, его типами данных(Sets, strings, Hashes, Lists), а также построить всю архитектуру приложения именно на Redis, так как это несложно в разработке, удобно, и работает достаточно быстро, плюс его удобно горизонтально масштабировать(если бы я просто писал на map внутри оперативы, то ни о каком масштабировании речи бы не шло). В качестве языка программирования был выбран мой любимый Golang. 

## Общая информация о приложении(как им можно пользоваться?)
Фронтенд был написан на html+css, т.е. бэкенд раздаёт статику. 

1. При переходе на страницу сразу виден интерфейс, по которому можно создать, либо подключиться к комнате. 

![](assets/first.png)

2. В разделе ID комнаты можно как придумать своё уникальное название, которое удобно вводить вам и вашему собеседнику, а можно нажать кнопку `Создать` и ID комнаты автоматически сгенерируется, комната создастся и будет установлено двустороннее соединение между клиентом и сервером. Если же вам нужно подключиться к комнате собеседника, то вам нужно знать ID комнаты, либо её название, и тогда вы сможете начать общение. 
![вот так выглядит создание комнаты и автоматическое подключение](assets/second.png)

3. Зайдём в комнату со стороны другого пользователя и посмотрим, как работает приём и отправка сообщений

![отправка сообщения](assets/third.png)
![получение сообщения](assets/fourth.png)

4. Чтобы выйти из комнаты достаточно нажать кнопку `Покинуть комнату`, если в комнате останется хотя бы 1 участник, то она не будет удалена, но если все пользователи вышли, то комната закроется. 

![выход из комнаты](assets/fifth.png)

Это были основные use cases приложения. Всё достаточно просто и интуитивно. Хотелось бы упомянуть, что я также встроил возможность видеочата через `LiveKit`, бэкенд помимо администрированием комнат занимается ещё и выдачей LiveKit токенов. Однако ввиду моих способностей во Фронтенде и ограничений по времени я пока не встроил LiveKit внутрь моего клиента. Думаю, что в будущих версиях я ещё вернусь к этому вопросу. Так как я бэкенд разработчик, то меня в первую очередь интересует написание отказоустойчивого решения с использованием современных технологий и хороших практик. Поэтому посмотрим, как устроена архитектура изнутри. 


## Архитектура решения (и немного теории)

Сердцем, главной технологией и причиной написания этого проекта является websocket. По сути, это надстройка над TCP: также устанавливается двустороннее долгоживущее соединение, тоже есть аналог Handshake(только в TCP он происходит 1 раз, а в вебсокетах постоянно). Главное отличие в том, что TCP передаёт байты, а вебсокеты обмениваются посредством фреймов(сообщений), именно поэтому TCP относится к 4 - транспортному уровню модели OSI, а WebSocket уже относится к прикладному уровню. За счёт своего внутреннего устройства и постоянного Ping/Pong вебсокеты лучше подходят под наше приложение, чем если бы посредством http обменивались данными. Из плюсов вебсокетов я бы выделил:
 - низкая задержка(доставка через вебсокеты практически мгновенная)
 - двунаправленность соединения(в http инициатива идёт от клиента, и только потом сервер отвечает)
 - Polling через http грузит ресурсы нашего сервера, плюс тратит больший трафик, чем вебсокет.
 
`Но самый главный плюс вебсокетов - простота реализации на уровне кода!`

Посмотрим на код, и на основную логику настройки сокетов. В качестве основного пакета я использовал `net/http`(для поднятия сервера) и `gorilla`(для вебсокетов). 
``` 

type wsServer struct {
	Updater *websocket.Upgrader // именно эта штука превратит наше соединение в веб сокет
	Hub     *hub.Hub //архитектурная концепция, о ней поговорим чуть позже
	Mux     *http.ServeMux  //мультиплексер
	Srv     *http.Server //сам сервер
}

func NewWsServer(hub *hub.Hub, addr string) *wsServer {
	//инициализация
}

func (ws *wsServer) Start() error {
    //запуск хаба в горутине
	go ws.Hub.Run()
	ws.Mux.HandleFunc("/", StaticHandler)
	ws.Mux.HandleFunc("/ws", ws.WebSocketHandler)
	return ws.Srv.ListenAndServe()
}

func (ws *wsServer) Stop(ctx context.Context) error {
	return ws.Srv.Shutdown(ctx)
}

//ручка под статику
func StaticHandler(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "index.html")
}

//ручка под вебсокет 
func (s *wsServer) WebSocketHandler(w http.ResponseWriter, r *http.Request) {
    //апгрейдим наше соединение до вебсокета
	conn, err := s.Updater.Upgrade(w, r, nil)
	if err != nil {
		log.Println("Ошибка апгрейда WebSocket:", err)
		return
	}
	roomID := r.URL.Query().Get("room")
	if roomID == "" {
		roomID = uuid.New().String()
	}
    //создаём обьект клиента
	c := &client.Client{
		ID:        uuid.New().String(),
		Conn:      conn,
		Send:      make(chan []byte, 256),
		Room:      roomID,
		UserAgent: r.UserAgent(),
	}
    //в канал регистрации хаба пишем нашего клиента
	s.Hub.Register <- c
	log.Printf("Client with id %s is in room: %s", c.ID, roomID)
	welcomeMsg := map[string]interface{}{
		"type":     "welcome",
		"clientId": c.ID,
		"roomId":   roomID,
	}
    //отправляем сообщение клиенту о том, что он попал в комнату
	if err := conn.WriteJSON(welcomeMsg); err != nil {
		log.Printf("Error to send welcome: %v", err)
	}
    //в фоне запускаем процессы чтения и записи сообщений
	go c.WritePump()
	go c.ReadPump(s.Hub.BroadcastToRoom)
}
```